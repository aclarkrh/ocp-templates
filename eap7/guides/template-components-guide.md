# Template Components Guide

The template components consist of the following main parts:
 - Kubernetes DSL Classes
 - S2I builder
 - POM Configuration

This guide will describe how these components function to enable an application to be deployed to OpeenShift.

## Kubernetes DSL
Kubernetes DSL provides a typesafe mechanism for automatically generating Kubernetes (and therefore OpenShift) configuration. This allows us to treat the OpenShift configuration as code and version control is as you would with any other code artefact.

The DSL definition is provided by a set of Fabric8 Maven dependencies (see POM Configuration below) and is converted to valid JSON configuration using fabric8-maven-plugin. When the project is built, using the appropriate Maven profile (kube-dsl), JSON configuration files are generated using the configuration described using the DSL.

The DSL provided in the template components is located under `src/config/java`. The provided classes will need to be modified to meet the configuration requirements of each application by editing the Java classes and also modifying the package name to match the application's package naming conventions.

Note that throughout the configuration classes parameters are used to specify values, for example:

```java
  public static final String APPLICATION_NAME = "${APPLICATION_NAME}";
```
This is so that template parameters can be used in the generated configuration. See POM Configuration below for details of how to specify these parameters and default values.

There is also a groovy script provided in the template components, `src/config/resources/spilt-templates.groovy`. This script will split the JSON generated by the Maven plugin (`kubernetes.json`) into two files for build (`kubernetes-build.json`) and run (`kubernetes-run.json`) config. This allows the build config to be used in the application's OpenShift build namespace (-bld) and the run config to be used in the application's OpenShift run namespaces (-dev, -tst, etc.).

One important step that this script performs is to include the required parameters in the buid and run configs when split. This is performed using parameter lists in the script:

```groovy
  def buildParams = ['APPLICATION_NAME', 'APPLICATION_VERSION', 'SOURCE_REPOSITORY_REF', 'GIT_URI', 'CONTEXT_DIR', 'SOURCE_SECRET', 'APP_IS_TAG', 'WAR_FILE_URL', 'XPAAS_IS_NAME', 'XPAAS_IS_TAG', 'XPAAS_IS_PULL_NAMESPACE']
  def deployParams = ['APPLICATION_NAME', 'APPLICATION_VERSION', 'APP_IS_PULL_NAMESPACE', 'HOSTNAME_HTTP', 'HOSTNAME_HTTPS', 'READINESS_PROBE_PATH', 'LIVENESS_PROBE_PATH', 'PERSISTENT_VOLUME_CLAIM_SIZE', 'PERSISTENT_VOLUME_MOUNT_PATH', 'CPU_REQUEST', 'MEM_REQUEST', 'CPU_LIMIT', 'MEM_LIMIT']
```
If parameters are added to or deleted from the application, these parameter lists must also be modified.

The following blog post provides a good introduction to Kubernetes DSL:

[Typesafe Kubernetes-manifest DSL for JVM-based apps](http://blog.christianposta.com/typesafe-kubernetes-dsl-for-yaml-json-generation/)

## S2I Builder
The build pipeline for applications consists of first building the application binary (usually a WAR file for EAP applications) and then building the container image. The S2I builder in this instance is responsible for building the container image from an application binary built abd deployed to Artifactory.

In order to do this the standard S2I builder provided by the JBoss EAP xPaaS image has been extended to get the application binary from Artifactory. This has been done by adding the following lines to the assemble script located under `.s2i/bin/assemble`.

```bash
if [ x"$WAR_FILE_URL" != "x" ]; then
  echo "grabbing the artifact $WAR_FILE_URL"
  curl -o ${DEPLOY_DIR}/ROOT.war -O ${WAR_FILE_URL}
else
  # If a pom.xml is present, this is a normal build scenario
  # so run maven.

  ...
  # code for Maven build already in script
  ...

fi
```
The additional lines will check for a populated parameter named `WAR_FILE_URL`. If this parameter value exists it will be used as the URL to curl the WAR file from and insert into the container image's EAP deployment directory, renaming the WAR file to ROOT.war. As a result when a container is started using the image, JBoss EAP will start with the application deployed to the root context.

## POM Configuration
The additional content in the application POM file is for several purposes:
 - To enable separation of standard application source code from source code used to build and configure the application for OpenShift.
 - To add configuration parameters and default values used in the OpenShift (Kubernetes) configuration.
 - To add the dependencies and plugins required for config generation using Kubernetes DSL.

Where possible all additional configuration has been added within the profile named `kube-dsl`.

It is assumed that the reader is familiar with Maven POM configuration generally and is able to read the template POM file and see where the above has been implemented.

### Configuration Parameters
The configuration parametes are added within the profile's `<properties>` element. Each parameter requires a parameter name, description and default value. The following snippet shows the layout of a single parameter.

```xml
  <fabric8.parameter.PARAMETER_NAME.description>...parameter description...</fabric8.parameter.PARAMETER_NAME.description>
  <fabric8.parameter.PARAMETER_NAME.value>...parameter value...</fabric8.parameter.PARAMETER_NAME.value>
```

These parameters will then be present in the generated Kubernetes config.
